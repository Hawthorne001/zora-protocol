# Explore Queries

The Coins SDK provides several explore functions to discover coins based on different criteria such as market performance, volume, and recency. These queries are useful for building discovery interfaces, trending sections, and leaderboards.

### Queries:

- [`getCoinsTopGainers`](#getcoinstopgainers)
- [`getCoinsTopVolume24h`](#getcoinstopvolume24h)
- [`getCoinsMostValuable`](#getcoinsmostvaluable)
- [`getCoinsNew`](#getcoinsnew)
- [`getCoinsLastTraded`](#getcoinslasttraded)
- [`getCoinsLastTradedUnique`](#getcoinslasttradedunique) 

## Available Explore Queries

### getCoinsTopGainers

The `getCoinsTopGainers` function retrieves coins that have increased the most in market cap over the last 24 hours.

#### Parameters

```typescript
type ExploreQueryOptions = {
  after?: string;     // Optional: Pagination cursor for fetching next page
  count?: number;     // Optional: Number of coins to return per page (default: 20)
};
```

#### Usage Example

```typescript
import { getCoinsTopGainers } from "@zoralabs/coins-sdk";

async function fetchTopGainers() {
  try {
    const response = await getCoinsTopGainers({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`Top Gainers (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      const percentChange = coin.marketCapDelta24h 
        ? `${parseFloat(coin.marketCapDelta24h).toFixed(2)}%` 
        : "N/A";
      
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   24h Change: ${percentChange}`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log(`   Volume 24h: ${coin.volume24h}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching top gainers:", error);
    throw error;
  }
}
```

### getCoinsTopVolume24h

The `getCoinsTopVolume24h` function retrieves coins with the highest trading volume in the last 24 hours.

#### Usage Example

```typescript
import { getCoinsTopVolume24h } from "@zoralabs/coins-sdk";

async function fetchTopVolumeCoins() {
  try {
    const response = await getCoinsTopVolume24h({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`Top Volume Coins (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   Volume 24h: ${coin.volume24h}`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log(`   Holders: ${coin.uniqueHolders}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching top volume coins:", error);
    throw error;
  }
}
```

### getCoinsMostValuable

The `getCoinsMostValuable` function retrieves coins with the highest market capitalization.

#### Usage Example

```typescript
import { getCoinsMostValuable } from "@zoralabs/coins-sdk";

async function fetchMostValuableCoins() {
  try {
    const response = await getCoinsMostValuable({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`Most Valuable Coins (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log(`   Volume 24h: ${coin.volume24h}`);
      console.log(`   Created: ${coin.createdAt}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching most valuable coins:", error);
    throw error;
  }
}
```

### getCoinsNew

The `getCoinsNew` function retrieves the most recently created coins.

#### Usage Example

```typescript
import { getCoinsNew } from "@zoralabs/coins-sdk";

async function fetchNewCoins() {
  try {
    const response = await getCoinsNew({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`New Coins (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      // Format the creation date for better readability
      const creationDate = new Date(coin.createdAt || "");
      const formattedDate = creationDate.toLocaleString();
      
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   Created: ${formattedDate}`);
      console.log(`   Creator: ${coin.creatorAddress}`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching new coins:", error);
    throw error;
  }
}
```

### getCoinsLastTraded

The `getCoinsLastTraded` function retrieves coins that have been traded most recently.

#### Usage Example

```typescript
import { getCoinsLastTraded } from "@zoralabs/coins-sdk";

async function fetchLastTradedCoins() {
  try {
    const response = await getCoinsLastTraded({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`Recently Traded Coins (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log(`   Volume 24h: ${coin.volume24h}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching last traded coins:", error);
    throw error;
  }
}
```

### getCoinsLastTradedUnique

The `getCoinsLastTradedUnique` function retrieves coins that have been traded by unique traders most recently.

#### Usage Example

```typescript
import { getCoinsLastTradedUnique } from "@zoralabs/coins-sdk";

async function fetchLastTradedUniqueCoins() {
  try {
    const response = await getCoinsLastTradedUnique({
      count: 10,        // Optional: number of coins per page
      after: undefined, // Optional: for pagination
    });
    
    console.log(`Recently Traded Coins by Unique Traders (${response.zora20Tokens?.length || 0} coins):`);
    
    response.zora20Tokens?.forEach((coin, index) => {
      console.log(`${index + 1}. ${coin.name} (${coin.symbol})`);
      console.log(`   Market Cap: ${coin.marketCap}`);
      console.log(`   Volume 24h: ${coin.volume24h}`);
      console.log(`   Unique Holders: ${coin.uniqueHolders}`);
      console.log('-----------------------------------');
    });
    
    // For pagination
    if (response.pagination?.cursor) {
      console.log("Next page cursor:", response.pagination.cursor);
    }
    
    return response;
  } catch (error) {
    console.error("Error fetching last traded unique coins:", error);
    throw error;
  }
}
```

## Response Structure

All explore queries return a similar response structure:

```typescript
{
  zora20Tokens?: Array<{
    // Same structure as the coin object in getCoin response
    id?: string;
    name?: string;
    description?: string;
    address?: string;
    symbol?: string;
    totalSupply?: string;
    totalVolume?: string;
    volume24h?: string;
    createdAt?: string;
    creatorAddress?: string;
    marketCap?: string;
    marketCapDelta24h?: string;
    chainId?: number;
    uniqueHolders?: number;
    // ... other coin properties
  }>;
  pagination?: {
    cursor?: string;  // Cursor for the next page
  };
}
```

## Pagination

Most explore queries support pagination to handle large result sets. Here's an example of how to implement pagination to fetch all coins that match a particular explore query:

```typescript
import { getCoinsTopGainers } from "@zoralabs/coins-sdk";

async function fetchAllTopGainers() {
  let allCoins = [];
  let cursor = undefined;
  const pageSize = 20;
  
  try {
    // Continue fetching until no more pages
    do {
      const response = await getCoinsTopGainers({
        count: pageSize,
        after: cursor,
      });
      
      // Add coins to our collection
      if (response.zora20Tokens && response.zora20Tokens.length > 0) {
        allCoins = [...allCoins, ...response.zora20Tokens];
      }
      
      // Update cursor for next page
      cursor = response.pagination?.cursor;
      
      // Break if no more results
      if (!cursor || response.zora20Tokens?.length === 0) {
        break;
      }
      
    } while (true);
    
    console.log(`Fetched ${allCoins.length} total top gaining coins`);
    return allCoins;
  } catch (error) {
    console.error("Error fetching all top gainers:", error);
    throw error;
  }
}
```

## Building Custom UIs

These explore queries are particularly useful for creating dynamic UIs like:

### Leaderboards
{/* 
```tsx
import { getCoinsMostValuable } from "@zoralabs/coins-sdk";
import { useEffect, useState } from "react";

function LeaderboardComponent() {
  const [coins, setCoins] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const response = await getCoinsMostValuable({ count: 10 });
        setCoins(response.zora20Tokens || []);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    
    fetchData();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h2>Top Coins by Market Cap</h2>
      <table>
        <thead>
          <tr>
            <th>Rank</th>
            <th>Coin</th>
            <th>Market Cap</th>
            <th>24h Volume</th>
          </tr>
        </thead>
        <tbody>
          {coins.map((coin, index) => (
            <tr key={coin.id}>
              <td>{index + 1}</td>
              <td>
                {coin.media?.previewImage && (
                  <img 
                    src={coin.media.previewImage} 
                    alt={coin.name} 
                    width="30" 
                    height="30" 
                    style={{ borderRadius: '50%', marginRight: '10px' }}
                  />
                )}
                {coin.name} ({coin.symbol})
              </td>
              <td>${parseFloat(coin.marketCap || "0").toLocaleString()}</td>
              <td>${parseFloat(coin.volume24h || "0").toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
``` */}

### Trending Section

<iframe src="https://codesandbox.io/embed/76s933?view=editor+%2B+preview&module=%2Fsrc%2FApp.tsx"
     title="coins-leaderboard"
     style={{width: '100%', height: '500px', border: '0', borderRadius: '4px', overflow: 'hidden'}}
     sandbox="allow-forms allow-modals allow-popups allow-scripts"
   ></iframe>

## Best Practices

1. **Implement Caching**: Consider caching the results of these queries to reduce API calls, especially for frequently accessed data like trending coins.

2. **Use Appropriate Page Sizes**: Choose a reasonable page size based on your UI requirements. Smaller page sizes (10-20 items) generally provide better user experience.

3. **Implement Error Handling**: Always handle errors gracefully in your UI, providing helpful feedback to users when API calls fail.

4. **Conditional Rendering**: Make sure your UI components can handle missing or undefined data, as some fields might not be available for all coins.

5. **Refresh Strategy**: Consider implementing a refresh strategy for time-sensitive data like "Top Gainers" or "Highest Volume" (e.g., refresh every 5 minutes).

6. **Loading States**: Show appropriate loading states when fetching data to provide feedback to users.

7. **Combine Queries**: For more complex UIs, you might need to combine multiple explore queries. Consider using Promise.all to fetch data in parallel.
